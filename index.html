<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hydropower Plant Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #f0f8ff;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            max-width: 300px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        #controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 150px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 250px;
            height: 8px;
            border-radius: 4px;
            background: #505050;
            outline: none;
        }
        .value-display {
            display: inline-block;
            width: 60px;
            text-align: right;
            margin-left: 10px;
            font-weight: bold;
        }
        #power-display {
            margin-top: 20px;
            padding: 10px;
            background: rgba(0, 100, 0, 0.3);
            border-radius: 5px;
            text-align: center;
        }
        #power-value {
            font-size: 24px;
            font-weight: bold;
            color: #7cfc00;
        }
        h1, h2, h3 {
            margin-top: 0;
        }
        .info-text {
            line-height: 1.5;
        }
        .highlight {
            color: #7cfc00;
            font-weight: bold;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }
        .progress-bar {
            width: 300px;
            height: 20px;
            border: 2px solid white;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        #progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #0077be, #00bfff);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h2>Loading Hydropower Plant Simulation</h2>
        <p>Please wait while we prepare the interactive experience...</p>
        <div class="progress-bar">
            <div id="progress"></div>
        </div>
    </div>


    
    <div id="controls-panel">
        <div class="control-group">
            <label for="gate-control">Water Flow Control:</label>
            <input type="range" id="gate-control" min="0" max="100" value="0">
            <span class="value-display" id="gate-value">0%</span>
        </div>
        <div class="control-group">
            <label for="camera-control">Camera View:</label>
            <input type="range" id="camera-control" min="1" max="4" value="1" step="1">
            <span class="value-display" id="view-value">1</span>
        </div>
        <div id="power-display">
            <div>Current Power Output:</div>
            <div id="power-value">0 kW</div>
            <div id="efficiency">Efficiency: 0%</div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

    <script>
        // Main simulation variables
        let scene, camera, renderer, controls;
        let water, turbine, generator, bulb, light;
        let gateLeft, gateRight, waterSurface;
        let waterParticles = [];
        let waterfall;
        let turbineRotationSpeed = 0;
        let gateOpeningPercentage = 0;
        let previousTime = 0;
        let powerOutput = 0;
        let efficiency = 0;
        let loadingComplete = false;
        
        // Camera positions with descriptions
        const cameraPositions = [
            { x: 0, y: 15, z: 40, desc: "Overview" },
            { x: -25, y: 10, z: 20, desc: "Side View" },
            { x: 0, y: 2, z: 15, desc: "Turbine Close-up" },
            { x: 0, y: 30, z: 5, desc: "Top-down View" }
        ];
        
        // Initialize the scene with loading progress
        function init() {
            // Simulate loading progress
            const loadingInterval = setInterval(() => {
                const progress = document.getElementById('progress');
                const currentWidth = parseInt(progress.style.width) || 0;
                if (currentWidth < 100) {
                    progress.style.width = (currentWidth + 10) + '%';
                } else {
                    clearInterval(loadingInterval);
                    document.getElementById('loading-screen').style.display = 'none';
                    loadingComplete = true;
                }
            }, 200);
            
            // Create scene with improved lighting
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.002);
            
            // Create camera with orbit controls
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraPositions[0].x, cameraPositions[0].y, cameraPositions[0].z);
            
            // Create renderer with enhanced settings
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);
            
            // Add orbit controls for manual camera movement
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI * 0.9;
            controls.minDistance = 10;
            controls.maxDistance = 100;
            
            // Setup lighting
            setupLighting();
            
            // Create environment
            createEnvironment();
            
            // Create dam structure
            createDam();
            
            // Create water reservoir
            createReservoir();
            
            // Create control gates
            createGates();
            
            // Create turbine house and generator
            createTurbineHouse();
            
            // Create turbine and generator
            createTurbineAndGenerator();
            
            // Create bulb and light
            createBulbAndLight();
            
            // Create power lines and transformer
            createPowerInfrastructure();
            
            // Create waterfall effect
            createWaterfall();
            
            // Add event listeners
            setupEventListeners();
            
            // Start animation loop
            animate();
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
            sunLight.position.set(10, 20, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -30;
            sunLight.shadow.camera.right = 30;
            sunLight.shadow.camera.top = 30;
            sunLight.shadow.camera.bottom = -30;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);
            
            // Hemisphere light for natural outdoor lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x228B22, 0.5);
            scene.add(hemisphereLight);
            
            // Add some point lights inside the turbine house
            const interiorLight1 = new THREE.PointLight(0xfff4e5, 0.8, 10);
            interiorLight1.position.set(-3, 0, 3);
            scene.add(interiorLight1);
            
            const interiorLight2 = new THREE.PointLight(0xfff4e5, 0.8, 10);
            interiorLight2.position.set(3, 0, 3);
            scene.add(interiorLight2);
        }
        
        function createEnvironment() {
            // Create terrain with more natural variation
            const groundSize = 200;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 100, 100);
            
            // Displace vertices to create terrain
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                const distanceToCenter = Math.sqrt(x * x + z * z);
                
                if (distanceToCenter > 30) {
                    // Create more natural terrain with Perlin-like noise
                    vertices[i + 1] = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3 +
                                     Math.sin(x * 0.05) * Math.cos(z * 0.05) * 6;
                }
            }
            
            // Calculate normals for proper lighting
            groundGeometry.computeVertexNormals();
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a5f0b,
                roughness: 0.9,
                metalness: 0.0
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Create downstream river
            const riverGeometry = new THREE.PlaneGeometry(groundSize, 30, 32, 32);
            riverGeometry.rotateX(-Math.PI / 2);
            
            const riverMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0077be,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.3
            });
            
            const river = new THREE.Mesh(riverGeometry, riverMaterial);
            river.position.set(0, -4.9, 50);
            river.receiveShadow = true;
            scene.add(river);
            
            // Add mountains in the background
            createMountains();
            
            // Add vegetation (trees, bushes)
            createVegetation();
        }
        
        function createMountains() {
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a5a5a,
                roughness: 1.0,
                metalness: 0.0
            });
            
            // Create several mountains with varying sizes
            for (let i = 0; i < 8; i++) {
                const segments = Math.floor(5 + Math.random() * 5);
                const radius = 15 + Math.random() * 15;
                const height = 20 + Math.random() * 30;
                
                const mountainGeometry = new THREE.ConeGeometry(radius, height, segments);
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                
                // Position mountains in a circle around the scene
                const angle = (i / 8) * Math.PI * 2;
                const distance = 80 + Math.random() * 40;
                mountain.position.set(
                    Math.sin(angle) * distance,
                    -5 + height / 2,
                    Math.cos(angle) * distance
                );
                
                // Random rotation for more natural look
                mountain.rotation.y = Math.random() * Math.PI * 2;
                
                mountain.castShadow = true;
                mountain.receiveShadow = true;
                scene.add(mountain);
            }
        }
        
        function createVegetation() {
            // Tree materials
            const leafMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a5f1a,
                roughness: 0.9
            });
            
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a3a1a,
                roughness: 0.8
            });
            
            // Create multiple trees
            for (let i = 0; i < 50; i++) {
                const tree = new THREE.Group();
                
                // Trunk
                const trunkHeight = 2 + Math.random() * 1;
                const trunkRadius = 0.3 + Math.random() * 0.2;
                const trunkGeometry = new THREE.CylinderGeometry(
                    trunkRadius * 0.8, trunkRadius, trunkHeight, 8
                );
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // Leaves (multiple layers for more realistic trees)
                const leavesLayers = 2 + Math.floor(Math.random() * 2);
                for (let j = 0; j < leavesLayers; j++) {
                    const leavesRadius = 1.5 + Math.random() * 1;
                    const leavesHeight = 2 + Math.random() * 1;
                    const leavesGeometry = new THREE.ConeGeometry(
                        leavesRadius, leavesHeight, 8
                    );
                    const leaves = new THREE.Mesh(leavesGeometry, leafMaterial);
                    leaves.position.y = trunkHeight + (j * leavesHeight * 0.7);
                    leaves.castShadow = true;
                    tree.add(leaves);
                }
                
                // Position tree randomly, avoiding the dam area
                let x, z;
                do {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 100;
                    x = Math.sin(angle) * distance;
                    z = Math.cos(angle) * distance;
                } while (Math.abs(x) < 25 && z > -40 && z < 20);
                
                tree.position.set(x, -5, z);
                
                // Random scale variation
                const scale = 0.7 + Math.random() * 0.6;
                tree.scale.set(scale, scale, scale);
                
                // Slight random rotation
                tree.rotation.y = Math.random() * Math.PI * 2;
                
                scene.add(tree);
            }
        }
        function createDam() {
            // Load concrete texture
            const concreteTexture = new THREE.TextureLoader().load(
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/brick_diffuse.jpg'
            );
            concreteTexture.wrapS = concreteTexture.wrapT = THREE.RepeatWrapping;
            concreteTexture.repeat.set(4, 4);
            
            const concreteBumpMap = new THREE.TextureLoader().load(
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/brick_bump.jpg'
            );
            concreteBumpMap.wrapS = concreteBumpMap.wrapT = THREE.RepeatWrapping;
            concreteBumpMap.repeat.set(4, 4);
            
            // Main dam wall
            const damGeometry = new THREE.BoxGeometry(25, 18, 4);
            const damMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x909090,
                roughness: 0.7,
                metalness: 0.1,
                map: concreteTexture,
                bumpMap: concreteBumpMap,
                bumpScale: 0.1
            });
            
            const dam = new THREE.Mesh(damGeometry, damMaterial);
            dam.position.set(0, 1, -5);
            dam.castShadow = true;
            dam.receiveShadow = true;
            scene.add(dam);
            
            // Add structural supports
            createDamSupports();
            
            // Dam top structure
            createDamTopStructure();
            
            // Gate opening
            const gateOpeningGeometry = new THREE.BoxGeometry(8, 6, 5);
            const gateOpeningMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 1,
                metalness: 0 
            });
            const gateOpening = new THREE.Mesh(gateOpeningGeometry, gateOpeningMaterial);
            gateOpening.position.set(0, -3, -3.5);
            scene.add(gateOpening);
        }
        
        function createDamSupports() {
            const supportMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x707070,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Buttresses
            for (let i = -1; i <= 1; i += 2) {
                const buttressGeometry = new THREE.BoxGeometry(2, 15, 8);
                const buttress = new THREE.Mesh(buttressGeometry, supportMaterial);
                buttress.position.set(i * 11, -1.5, -3);
                buttress.castShadow = true;
                buttress.receiveShadow = true;
                scene.add(buttress);
            }
            
            // Diagonal supports
            for (let i = -1; i <= 1; i += 2) {
                const supportGeometry = new THREE.BoxGeometry(1, 1, 15);
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(i * 8, 5, -12);
                support.rotation.x = Math.PI / 6 * i;
                support.castShadow = true;
                support.receiveShadow = true;
                scene.add(support);
            }
        }
        
        function createDamTopStructure() {
            const topMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x606060,
                roughness: 0.6,
                metalness: 0.2
            });
            
            // Dam top walkway
            const walkwayGeometry = new THREE.BoxGeometry(27, 1, 6);
            const walkway = new THREE.Mesh(walkwayGeometry, topMaterial);
            walkway.position.set(0, 9, -5);
            walkway.receiveShadow = true;
            scene.add(walkway);
            
            // Railings
            const railingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x404040,
                roughness: 0.5,
                metalness: 0.8
            });
            
            // Vertical posts
            for (let i = -12; i <= 12; i += 2) {
                const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                const post = new THREE.Mesh(postGeometry, railingMaterial);
                post.position.set(i, 9.8, -5);
                scene.add(post);
            }
            
            // Horizontal rails
            const railGeometry = new THREE.CylinderGeometry(0.06, 0.06, 27, 8);
            railGeometry.rotateZ(Math.PI / 2);
            
            for (let i = 0; i < 2; i++) {
                const rail = new THREE.Mesh(railGeometry, railingMaterial);
                rail.position.set(0, 9.5 + i * 0.3, -5);
                scene.add(rail);
            }
            
            // Side rails
            const sideRailGeometry = new THREE.CylinderGeometry(0.06, 0.06, 6, 8);
            sideRailGeometry.rotateX(Math.PI / 2);
            
            for (let i = -1; i <= 1; i += 2) {
                const sideRail = new THREE.Mesh(sideRailGeometry, railingMaterial);
                sideRail.position.set(i * 13.5, 9.7, -5);
                scene.add(sideRail);
            }
        }
        
        function createReservoir() {
            // Water surface with waves
            const waterGeometry = new THREE.PlaneGeometry(40, 25, 64, 64);
            waterGeometry.rotateX(-Math.PI / 2);
            
            const waterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0077be,
                transparent: true,
                opacity: 0.85,
                roughness: 0.1,
                metalness: 0.3,
                side: THREE.DoubleSide
            });
            
            waterSurface = new THREE.Mesh(waterGeometry, waterMaterial);
            waterSurface.position.set(0, 7, -15);
            waterSurface.userData = {
                originalVertices: Array.from(waterGeometry.attributes.position.array),
                time: 0
            };
            scene.add(waterSurface);
            
            // Reservoir walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Left wall
            const leftWallGeometry = new THREE.BoxGeometry(1, 18, 25);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-20.5, 1, -15);
            leftWall.receiveShadow = true;
            leftWall.castShadow = true;
            scene.add(leftWall);
            
            // Right wall
            const rightWallGeometry = new THREE.BoxGeometry(1, 18, 25);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.set(20.5, 1, -15);
            rightWall.receiveShadow = true;
            rightWall.castShadow = true;
            scene.add(rightWall);
            
            // Back wall
            const backWallGeometry = new THREE.BoxGeometry(42, 18, 1);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 1, -27.5);
            backWall.receiveShadow = true;
            backWall.castShadow = true;
            scene.add(backWall);
        }
        
        function createGates() {
            const gateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x505050,
                roughness: 0.3,
                metalness: 0.8
            });
            
            // Left gate
            const gateGeometry = new THREE.BoxGeometry(4, 6, 0.5);
            gateLeft = new THREE.Mesh(gateGeometry, gateMaterial);
            gateLeft.position.set(-2, -3, -3.5);
            gateLeft.castShadow = true;
            scene.add(gateLeft);
            
            // Right gate
            gateRight = new THREE.Mesh(gateGeometry, gateMaterial);
            gateRight.position.set(2, -3, -3.5);
            gateRight.castShadow = true;
            scene.add(gateRight);
            
            // Add gate details (handles, reinforcement)
            const detailMaterial = new THREE.MeshStandardMaterial({
                color: 0x303030,
                roughness: 0.3,
                metalness: 0.9
            });
            
            for (let j = 0; j < 2; j++) {
                const gate = j === 0 ? gateLeft : gateRight;
                
                // Handles
                for (let i = -1; i <= 1; i += 2) {
                    const handleGeometry = new THREE.TorusGeometry(0.4, 0.08, 16, 16);
                    const handle = new THREE.Mesh(handleGeometry, detailMaterial);
                    handle.position.set(j === 0 ? -0.8 : 0.8, i * 1.5, -3.2);
                    handle.rotation.y = Math.PI / 2;
                    gate.add(handle);
                }
                
                // Reinforcement bars
                for (let i = -2; i <= 2; i += 1) {
                    const barGeometry = new THREE.BoxGeometry(3.5, 0.3, 0.1);
                    const bar = new THREE.Mesh(barGeometry, detailMaterial);
                    bar.position.set(0, i, -0.2);
                    gate.add(bar);
                }
            }
        }
        
        function createTurbineHouse() {
            // Main house structure
            const houseGeometry = new THREE.BoxGeometry(12, 10, 10);
            const houseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xeeeeee,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.set(0, 0, 3);
            house.castShadow = true;
            house.receiveShadow = true;
            scene.add(house);
            
            // Roof
            const roofGeometry = new THREE.ConeGeometry(8, 4, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 6, 3);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            scene.add(roof);
            
            // Windows
            createHouseWindows();
            
            // Door
            createHouseDoor();
            
            // Water channel
            const channelGeometry = new THREE.BoxGeometry(8, 3, 12);
            const channelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x707070,
                roughness: 0.7
            });
            const channel = new THREE.Mesh(channelGeometry, channelMaterial);
            channel.position.set(0, -3.5, -2);
            channel.receiveShadow = true;
            scene.add(channel);
            
            // Pipes
            createPipes();
        }
        
        function createHouseWindows() {
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.2,
                emissive: 0x112233
            });
            
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x704214,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Window creation helper function
            const createWindow = (width, height) => {
                const windowGroup = new THREE.Group();
                
                // Glass
                const glass = new THREE.Mesh(
                    new THREE.PlaneGeometry(width, height),
                    windowMaterial
                );
                glass.position.z = 0.01;
                windowGroup.add(glass);
                
                // Frame
                const frameHorizontal = new THREE.Mesh(
                    new THREE.BoxGeometry(width + 0.2, 0.2, 0.2),
                    frameMaterial
                );
                frameHorizontal.position.y = height / 2 + 0.1;
                windowGroup.add(frameHorizontal.clone());
                frameHorizontal.position.y = -height / 2 - 0.1;
                windowGroup.add(frameHorizontal.clone());
                
                const frameVertical = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, height + 0.2, 0.2),
                    frameMaterial
                );
                frameVertical.position.x = width / 2 + 0.1;
                windowGroup.add(frameVertical.clone());
                frameVertical.position.x = -width / 2 - 0.1;
                windowGroup.add(frameVertical.clone());
                
                return windowGroup;
            };
            
            // Front windows
            const frontWindow1 = createWindow(2, 2);
            frontWindow1.position.set(-4, 1, 10.01);
            scene.add(frontWindow1);
            
            const frontWindow2 = createWindow(2, 2);
            frontWindow2.position.set(4, 1, 10.01);
            scene.add(frontWindow2);
            
            // Side windows
            const sideWindow1 = createWindow(2, 2);
            sideWindow1.position.set(-10.01, 1, 0);
            sideWindow1.rotation.y = Math.PI / 2;
            scene.add(sideWindow1);
            
            const sideWindow2 = createWindow(2, 2);
            sideWindow2.position.set(10.01, 1, 0);
            sideWindow2.rotation.y = -Math.PI / 2;
            scene.add(sideWindow2);
        }
        
        function createHouseDoor() {
            const doorGroup = new THREE.Group();
            
            // Door
            const doorGeometry = new THREE.PlaneGeometry(2, 3);
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x5c2e11,
                roughness: 0.7
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.z = 0.01;
            doorGroup.add(door);
            
            // Door handle
            const handleGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const handle = new THREE.Mesh(handleGeometry, new THREE.MeshStandardMaterial({
                color: 0xe0c010,
                roughness: 0.4,
                metalness: 0.8
            }));
            handle.position.set(0.8, 0, 0.1);
            doorGroup.add(handle);
            
            doorGroup.position.set(0, -2, 10.01);
            scene.add(doorGroup);
        }
        
        function createPipes() {
            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x505050,
                roughness: 0.3,
                metalness: 0.8
            });
            
            // Main pipe from dam to turbine
            const mainPipeGeometry = new THREE.CylinderGeometry(1.2, 1.2, 12, 32);
            mainPipeGeometry.rotateX(Math.PI / 2);
            const mainPipe = new THREE.Mesh(mainPipeGeometry, pipeMaterial);
            mainPipe.position.set(0, -3, -1);
            mainPipe.castShadow = true;
            scene.add(mainPipe);
            
            // Smaller pipes
            const smallPipeGeometry = new THREE.CylinderGeometry(0.5, 0.5, 8, 32);
            for (let i = -1; i <= 1; i += 2) {
                const smallPipe = new THREE.Mesh(smallPipeGeometry, pipeMaterial);
                smallPipe.position.set(i * 3, -3, -1);
                smallPipe.castShadow = true;
                scene.add(smallPipe);
            }
        }
        
        function createTurbineAndGenerator() {
            // Turbine blades
            const bladeGeometry = new THREE.BoxGeometry(0.6, 5, 0.2);
            const bladeMaterial = new THREE.MeshStandardMaterial({
                color: 0x606060,
                roughness: 0.3,
                metalness: 0.8
            });
            
            turbine = new THREE.Group();
            for (let i = 0; i < 6; i++) {
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(0, 2.5, 0);
                blade.rotation.z = (i / 6) * Math.PI * 2;
                turbine.add(blade);
            }
            
            // Turbine hub
            const hubGeometry = new THREE.CylinderGeometry(1, 1, 0.5, 32);
            const hubMaterial = new THREE.MeshStandardMaterial({
                color: 0x404040,
                roughness: 0.2,
                metalness: 0.9
            });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            turbine.add(hub);
            
            turbine.position.set(0, -3, 0);
            turbine.castShadow = true;
            scene.add(turbine);
            
            // Generator housing
            const generatorGeometry = new THREE.CylinderGeometry(2, 2, 3, 32);
            const generatorMaterial = new THREE.MeshStandardMaterial({
                color: 0x707070,
                roughness: 0.4,
                metalness: 0.7
            });
            generator = new THREE.Mesh(generatorGeometry, generatorMaterial);
            generator.position.set(0, -3, 3);
            generator.rotation.x = Math.PI / 2;
            generator.castShadow = true;
            scene.add(generator);
            
            // Generator details
            const detailGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const detail = new THREE.Mesh(detailGeometry, generatorMaterial);
                detail.position.set(
                    Math.cos(angle) * 2.5,
                    -3,
                    3 + Math.sin(angle) * 2.5
                );
                scene.add(detail);
            }
        }
        
        function createBulbAndLight() {
            // Bulb glass
            const bulbGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const bulbMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffcc,
                emissive: 0xffff00,
                emissiveIntensity: 0,
                roughness: 0.1,
                metalness: 0.0,
                transparent: true,
                opacity: 0.9
            });
            
            bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(0, 6, 3);
            scene.add(bulb);
            
            // Light source
            light = new THREE.PointLight(0xffff00, 0, 15, 2);
            light.position.set(0, 6, 3);
            scene.add(light);
            
            // Bulb base
            const baseGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x303030,
                roughness: 0.4,
                metalness: 0.8
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(0, 5.2, 3);
            scene.add(base);
        }
        
        function createPowerInfrastructure() {
            // Power lines
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const wireMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                linewidth: 2
            });
            
            // Create power poles and wires
            for (let i = 0; i < 6; i++) {
                const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 12, 16);
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(i * 15 - 30, 0, 15);
                scene.add(pole);
                
                // Cross arms
                const crossArmGeometry = new THREE.BoxGeometry(4, 0.2, 0.2);
                const crossArm = new THREE.Mesh(crossArmGeometry, poleMaterial);
                crossArm.position.set(i * 15 - 30, 6, 15);
                scene.add(crossArm);
                
                // Wires
                if (i > 0) {
                    for (let j = -1; j <= 1; j++) {
                        const wireGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3((i - 1) * 15 - 30, 6 + j, 15),
                            new THREE.Vector3(i * 15 - 30, 6 + j, 15)
                        ]);
                        const wire = new THREE.Line(wireGeometry, wireMaterial);
                        scene.add(wire);
                    }
                }
            }
            
            // Transformer
            const transformerGeometry = new THREE.BoxGeometry(3, 4, 2);
            const transformerMaterial = new THREE.MeshStandardMaterial({
                color: 0x404040,
                roughness: 0.5,
                metalness: 0.7
            });
            const transformer = new THREE.Mesh(transformerGeometry, transformerMaterial);
            transformer.position.set(-10, 2, 15);
            scene.add(transformer);
            
            // Connection from generator to transformer
            const connectionGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -3, 3),
                new THREE.Vector3(-5, -3, 10),
                new THREE.Vector3(-10, 4, 15)
            ]);
            const connection = new THREE.Line(
                connectionGeometry,
                new THREE.LineBasicMaterial({ color: 0xff0000 })
            );
            scene.add(connection);
        }
        
        function createWaterfall() {
            // Waterfall effect
            const waterfallGeometry = new THREE.PlaneGeometry(8, 12, 8, 16);
            const waterfallMaterial = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.3,
                side: THREE.DoubleSide
            });
            
            waterfall = new THREE.Mesh(waterfallGeometry, waterfallMaterial);
            waterfall.position.set(0, -6, -3.5);
            waterfall.rotation.x = -Math.PI / 2;
            waterfall.visible = false;
            waterfall.userData = {
                originalVertices: Array.from(waterfallGeometry.attributes.position.array),
                time: 0
            };
            scene.add(waterfall);
        }
        
        function setupEventListeners() {
            // Gate control
            document.getElementById('gate-control').addEventListener('input', function(e) {
                gateOpeningPercentage = parseInt(e.target.value);
                document.getElementById('gate-value').textContent = gateOpeningPercentage + '%';
                updateGatePosition();
            });
            
            // Camera control
            document.getElementById('camera-control').addEventListener('input', function(e) {
                const viewIndex = parseInt(e.target.value) - 1;
                document.getElementById('view-value').textContent = e.target.value;
                
                gsap.to(camera.position, {
                    x: cameraPositions[viewIndex].x,
                    y: cameraPositions[viewIndex].y,
                    z: cameraPositions[viewIndex].z,
                    duration: 1.5,
                    onUpdate: function() {
                        camera.lookAt(0, 0, 0);
                    }
                });
            });
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function updateGatePosition() {
            const gatePosition = -3 + (gateOpeningPercentage / 100) * 6;
            gateLeft.position.y = gatePosition;
            gateRight.position.y = gatePosition;
            
            // Show/hide waterfall based on gate opening
            if (gateOpeningPercentage > 0) {
                waterfall.visible = true;
            } else {
                waterfall.visible = false;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - previousTime) / 1000;
            previousTime = currentTime;
            
            // Update controls if they're enabled
            if (controls && loadingComplete) {
                controls.update();
            }
            
            // Update turbine rotation based on gate opening
            turbineRotationSpeed = gateOpeningPercentage / 100;
            turbine.rotation.z += turbineRotationSpeed * deltaTime * Math.PI;
            
            // Update water surface animation
            if (waterSurface) {
                waterSurface.userData.time += deltaTime;
                const vertices = waterSurface.geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 1] = waterSurface.userData.originalVertices[i + 1] + 
                                     Math.sin(waterSurface.userData.time * 0.5 + vertices[i] * 0.1) * 0.3;
                }
                waterSurface.geometry.attributes.position.needsUpdate = true;
            }
            
            // Update waterfall animation
            if (waterfall && waterfall.visible) {
                waterfall.userData.time += deltaTime * 2;
                const vertices = waterfall.geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    // Create flowing water effect
                    vertices[i + 2] = waterfall.userData.originalVertices[i + 2] + 
                                     Math.sin(waterfall.userData.time + vertices[i] * 0.5) * 0.5;
                }
                waterfall.geometry.attributes.position.needsUpdate = true;
            }
            
            // Update power output and bulb brightness
            powerOutput = turbineRotationSpeed * 150; // Scale to more realistic values
            efficiency = Math.min(100, Math.round(powerOutput / 1.5)); // Efficiency percentage
            
            // Update bulb and light based on power output
            const bulbIntensity = Math.min(1, turbineRotationSpeed * 2);
            if (bulb) {
                bulb.material.emissiveIntensity = bulbIntensity;
            }
            if (light) {
                light.intensity = bulbIntensity;
            }
            
            // Update display
            document.getElementById('power-value').textContent = `${powerOutput.toFixed(1)} kW`;
            document.getElementById('efficiency').textContent = `Efficiency: ${efficiency}%`;
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Start the simulation
        init();
    </script>
</body>
</html>
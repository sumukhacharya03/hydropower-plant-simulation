<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydropower Plant Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 120px;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }
        .value-display {
            display: inline-block;
            width: 50px;
            text-align: right;
            margin-left: 10px;
        }
        #powerOutput {
            margin-top: 15px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Hydropower Plant Simulation</h2>
        <p>Use the controls to open and close the water gates.</p>
        <p>When water flows, the turbine rotates and generates electricity.</p>
    </div>
    
    <div id="controls">
        <div class="slider-container">
            <label for="gateControl">Gate Opening:</label>
            <input type="range" id="gateControl" min="0" max="100" value="0">
            <span class="value-display" id="gateValue">0%</span>
        </div>
        <div class="slider-container">
            <label for="cameraControl">Camera View:</label>
            <input type="range" id="cameraControl" min="1" max="4" value="1" step="1">
            <span class="value-display" id="viewValue">1</span>
        </div>
        <div id="powerOutput">Power Output: 0 kW</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    <script>
        // Main variables
        let scene, camera, renderer, water, turbine, bulb, light;
        let gateLeft, gateRight;
        let waterParticles = [];
        let waterfall;
        let turbineRotationSpeed = 0;
        let gateOpeningPercentage = 0;
        let previousTime = 0;
        let powerOutput = 0;
        
        // Camera positions
        const cameraPositions = [
            { x: 0, y: 10, z: 30 }, // Overview
            { x: -15, y: 8, z: 15 }, // Side view
            { x: 0, y: 2, z: 10 },   // Turbine focus
            { x: 0, y: 25, z: 5 }     // Top-down view
        ];
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background
            scene.fog = new THREE.Fog(0x87ceeb, 50, 100); // Add fog for depth
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 30);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);
            
            // Create lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.bias = -0.0001;
            scene.add(directionalLight);
            
            // Add some hemisphere light for more realistic outdoor lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x228B22, 0.5);
            scene.add(hemisphereLight);
            
            // Create environment
            createEnvironment();
            
            // Create dam structure
            createDam();
            
            // Create water reservoir
            createReservoir();
            
            // Create gates
            createGates();
            
            // Create turbine house
            createTurbineHouse();
            
            // Create turbine
            createTurbine();
            
            // Create bulb and light
            createBulbAndLight();
            
            // Create power lines
            createPowerLines();
            
            // Create waterfall mesh (initially invisible)
            createWaterfall();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Add controls
            document.getElementById('gateControl').addEventListener('input', function(e) {
                gateOpeningPercentage = parseInt(e.target.value);
                document.getElementById('gateValue').textContent = gateOpeningPercentage + '%';
                updateGatePosition();
            });
            
            document.getElementById('cameraControl').addEventListener('input', function(e) {
                const viewIndex = parseInt(e.target.value) - 1;
                document.getElementById('viewValue').textContent = e.target.value;
                
                gsap.to(camera.position, {
                    x: cameraPositions[viewIndex].x,
                    y: cameraPositions[viewIndex].y,
                    z: cameraPositions[viewIndex].z,
                    duration: 1.5,
                    onUpdate: function() {
                        camera.lookAt(0, 0, 0);
                    }
                });
            });
            
            // Start animation
            animate();
        }
        
        function createEnvironment() {
            // Create ground with better texture
            const groundSize = 200;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 32, 32);
            
            // Create a more interesting ground with height variations
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                // Skip the area near the dam
                const x = vertices[i];
                const z = vertices[i + 2];
                const distance = Math.sqrt(x * x + z * z);
                
                if (distance > 30) {
                    vertices[i + 1] = Math.sin(x / 20) * Math.cos(z / 20) * 2;
                }
            }
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8,
                metalness: 0.1,
                flatShading: true
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add water at the bottom
            const bottomWaterGeometry = new THREE.PlaneGeometry(groundSize, groundSize/2);
            const bottomWaterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0077be,
                transparent: true,
                opacity: 0.8,
                roughness: 0.2,
                metalness: 0.1
            });
            
            const bottomWater = new THREE.Mesh(bottomWaterGeometry, bottomWaterMaterial);
            bottomWater.rotation.x = -Math.PI / 2;
            bottomWater.position.set(0, -4.9, 50);
            scene.add(bottomWater);
            
            // Add some mountains in the background
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x4b6455,
                roughness: 1,
                metalness: 0
            });
            
            for (let i = 0; i < 5; i++) {
                const mountainGeometry = new THREE.ConeGeometry(15 + Math.random() * 10, 20 + Math.random() * 30, 5);
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                const angle = i * Math.PI / 2.5;
                const distance = 80 + Math.random() * 20;
                mountain.position.set(
                    Math.sin(angle) * distance,
                    -5 + mountain.geometry.parameters.height / 2,
                    -Math.cos(angle) * distance
                );
                mountain.castShadow = true;
                mountain.receiveShadow = true;
                scene.add(mountain);
            }
            
            // Add some trees
            const treeMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d5c0d,
                roughness: 0.9
            });
            
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8
            });
            
            for (let i = 0; i < 30; i++) {
                const treeGroup = new THREE.Group();
                
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                // Tree top (cone)
                const treeTopGeometry = new THREE.ConeGeometry(2, 5, 8);
                const treeTop = new THREE.Mesh(treeTopGeometry, treeMaterial);
                treeTop.position.y = 4.5;
                treeTop.castShadow = true;
                treeGroup.add(treeTop);
                
                // Position the tree randomly, avoiding the dam area
                let x, z;
                do {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 25 + Math.random() * 70;
                    x = Math.sin(angle) * distance;
                    z = Math.cos(angle) * distance;
                } while (Math.abs(x) < 20 && z > -30 && z < 15);
                
                treeGroup.position.set(x, -5, z);
                scene.add(treeGroup);
            }
        }
        
        function createDam() {
            // Create concrete texture for dam
            const concreteTexture = new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/brick_bump.jpg');
            concreteTexture.wrapS = concreteTexture.wrapT = THREE.RepeatWrapping;
            concreteTexture.repeat.set(2, 2);
            
            // Main dam wall with texture
            const damGeometry = new THREE.BoxGeometry(20, 15, 3);
            const damMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xB0B0B0,
                roughness: 0.7,
                metalness: 0.1,
                bumpMap: concreteTexture,
                bumpScale: 0.1
            });
            const dam = new THREE.Mesh(damGeometry, damMaterial);
            dam.position.set(0, 0, -5);
            dam.castShadow = true;
            dam.receiveShadow = true;
            scene.add(dam);
            
            // Add details to the dam for more realism
            // Buttresses
            const buttressMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xA0A0A0,
                roughness: 0.7,
                metalness: 0.1,
                bumpMap: concreteTexture,
                bumpScale: 0.05
            });
            
            for (let i = -1; i <= 1; i += 2) {
                const buttressGeometry = new THREE.BoxGeometry(1, 12, 6);
                const buttress = new THREE.Mesh(buttressGeometry, buttressMaterial);
                buttress.position.set(i * 9, -1.5, -3);
                buttress.castShadow = true;
                buttress.receiveShadow = true;
                scene.add(buttress);
            }
            
            // Dam top
            const damTopGeometry = new THREE.BoxGeometry(22, 1, 5);
            const damTopMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x606060,
                roughness: 0.6,
                metalness: 0.2,
                bumpMap: concreteTexture,
                bumpScale: 0.05
            });
            const damTop = new THREE.Mesh(damTopGeometry, damTopMaterial);
            damTop.position.set(0, 7.5, -5);
            damTop.receiveShadow = true;
            scene.add(damTop);
            
            // Dam top railing
            const railingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x505050,
                roughness: 0.5,
                metalness: 0.8
            });
            
            for (let i = -10; i <= 10; i += 2) {
                const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
                const post = new THREE.Mesh(postGeometry, railingMaterial);
                post.position.set(i, 8.5, -5);
                scene.add(post);
            }
            
            // Horizontal railings
            const railGeometry = new THREE.CylinderGeometry(0.05, 0.05, 22, 8);
            railGeometry.rotateZ(Math.PI / 2);
            const rail = new THREE.Mesh(railGeometry, railingMaterial);
            rail.position.set(0, 8.7, -5);
            scene.add(rail);
            
            const rail2 = new THREE.Mesh(railGeometry, railingMaterial);
            rail2.position.set(0, 8.3, -5);
            scene.add(rail2);
            
            // Gate opening in the middle
            const gateOpeningGeometry = new THREE.BoxGeometry(6, 5, 4);
            const gateOpeningMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 1,
                metalness: 0 
            });
            const gateOpening = new THREE.Mesh(gateOpeningGeometry, gateOpeningMaterial);
            gateOpening.position.set(0, -2.5, -3.5);
            scene.add(gateOpening);
        }
        
        function createReservoir() {
            // Water in reservoir with animated waves
            const waterGeometry = new THREE.PlaneGeometry(30, 20, 32, 32);
            waterGeometry.rotateX(-Math.PI / 2);
            
            // Create custom shader material for more realistic water
            const waterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0077be,
                transparent: true,
                opacity: 0.8,
                roughness: 0.2,
                metalness: 0.3,
                side: THREE.DoubleSide
            });
            
            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.set(0, 5, -15);
            water.userData = {
                originalVertices: Array.from(waterGeometry.attributes.position.array),
                time: 0
            };
            scene.add(water);
            
            // Add a subtle light effect under the water for more realism
            const waterLight = new THREE.PointLight(0x0077be, 0.5, 30);
            waterLight.position.set(0, 0, -15);
            scene.add(waterLight);
            
            // Reservoir walls with texture
            const wallTexture = new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/stone.jpg');
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(5, 2);
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.7,
                metalness: 0.1,
                map: wallTexture,
                bumpMap: wallTexture,
                bumpScale: 0.2
            });
            
            // Left wall
            const leftWallGeometry = new THREE.BoxGeometry(1, 15, 20);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-15.5, 0, -15);
            leftWall.receiveShadow = true;
            leftWall.castShadow = true;
            scene.add(leftWall);
            
            // Right wall
            const rightWallGeometry = new THREE.BoxGeometry(1, 15, 20);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.set(15.5, 0, -15);
            rightWall.receiveShadow = true;
            rightWall.castShadow = true;
            scene.add(rightWall);
            
            // Back wall
            const backWallGeometry = new THREE.BoxGeometry(32, 15, 1);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 0, -25.5);
            backWall.receiveShadow = true;
            backWall.castShadow = true;
            scene.add(backWall);
        }
        
        function createGates() {
            // Metal texture for gates
            const metalTexture = new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/metal.jpg');
            
            const gateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x505050,
                roughness: 0.4,
                metalness: 0.8,
                map: metalTexture,
                bumpMap: metalTexture,
                bumpScale: 0.1
            });
            
            // Left gate
            const gateGeometry = new THREE.BoxGeometry(3, 5, 0.5);
            gateLeft = new THREE.Mesh(gateGeometry, gateMaterial);
            gateLeft.position.set(-1.5, -2.5, -3.5);
            gateLeft.castShadow = true;
            scene.add(gateLeft);
            
            // Right gate
            gateRight = new THREE.Mesh(gateGeometry, gateMaterial);
            gateRight.position.set(1.5, -2.5, -3.5);
            gateRight.castShadow = true;
            scene.add(gateRight);
            
            // Add gate details
            // Gate handles
            const handleMaterial = new THREE.MeshStandardMaterial({
                color: 0x303030,
                roughness: 0.4,
                metalness: 0.9
            });
            
            for (let j = 0; j < 2; j++) {
                const gate = j === 0 ? gateLeft : gateRight;
                
                for (let i = -1; i <= 1; i += 2) {
                    const handleGeometry = new THREE.TorusGeometry(0.3, 0.05, 16, 16);
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.set(j === 0 ? -0.5 : 0.5, i, -3.2);
                    handle.rotation.y = Math.PI / 2;
                    gate.add(handle);
                }
                
                // Add reinforcement bars
                for (let i = -1.5; i <= 1.5; i += 1) {
                    const barGeometry = new THREE.BoxGeometry(2.5, 0.2, 0.1);
                    const bar = new THREE.Mesh(barGeometry, handleMaterial);
                    bar.position.set(0, i, -0.2);
                    gate.add(bar);
                }
            }
        }
        
        function createTurbineHouse() {
            // Brick texture for the turbine house
            const brickTexture = new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/brick_diffuse.jpg');
            brickTexture.wrapS = brickTexture.wrapT = THREE.RepeatWrapping;
            brickTexture.repeat.set(2, 2);
            
            const brickBumpMap = new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/brick_bump.jpg');
            brickBumpMap.wrapS = brickBumpMap.wrapT = THREE.RepeatWrapping;
            brickBumpMap.repeat.set(2, 2);
            
            // Turbine house
            const houseGeometry = new THREE.BoxGeometry(10, 8, 8);
            const houseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xeeeeee,
                roughness: 0.7,
                metalness: 0.1,
                map: brickTexture,
                bumpMap: brickBumpMap,
                bumpScale: 0.1
            });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.set(0, -1, 3);
            house.castShadow = true;
            house.receiveShadow = true;
            scene.add(house);
            
            // Roof texture
            const roofTexture = new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/wood.jpg');
            
            // Roof
            const roofGeometry = new THREE.ConeGeometry(7.5, 3, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7,
                map: roofTexture
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 4, 3);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            scene.add(roof);
            
            // Add windows
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.2,
                emissive: 0x112233
            });
            
            const windowFrameMaterial = new THREE.MeshStandardMaterial({
                color: 0x704214,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Add windows to the turbine house
            for (let i = -1; i <= 1; i += 2) {
                // Front window
                const windowGroup = new THREE.Group();
                
                const windowGeometry = new THREE.PlaneGeometry(2, 2);
                const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                window1.position.z = 0.01;
                windowGroup.add(window1);
                
                // Window frame
                const frameGeometry1 = new THREE.BoxGeometry(2.2, 0.2, 0.2);
                const frameTop = new THREE.Mesh(frameGeometry1, windowFrameMaterial);
                frameTop.position.y = 1.1;
                windowGroup.add(frameTop);
                
                const frameBottom = new THREE.Mesh(frameGeometry1, windowFrameMaterial);
                frameBottom.position.y = -1.1;
                windowGroup.add(frameBottom);
                
                const frameGeometry2 = new THREE.BoxGeometry(0.2, 2.4, 0.2);
                const frameLeft = new THREE.Mesh(frameGeometry2, windowFrameMaterial);
                frameLeft.position.x = -1.1;
                windowGroup.add(frameLeft);
                
                const frameRight = new THREE.Mesh(frameGeometry2, windowFrameMaterial);
                frameRight.position.x = 1.1;
                windowGroup.add(frameRight);
                
                // Center divider
                const dividerH = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 0.1),
                    windowFrameMaterial
                );
                windowGroup.add(dividerH);
                
                const dividerV = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 2, 0.1),
                    windowFrameMaterial
                );
                windowGroup.add(dividerV);
                
                windowGroup.position.set(i * 3, 0, 7.01);
                scene.add(windowGroup);
                
                // Side windows
                const sideWindowGroup = windowGroup.clone();
                sideWindowGroup.rotation.y = Math.PI / 2;
                sideWindowGroup.position.set(5.01, 0, 3 + i * 2);
                scene.add(sideWindowGroup);
                
                const sideWindowGroup2 = windowGroup.clone();
                sideWindowGroup2.rotation.y = -Math.PI / 2;
                sideWindowGroup2.position.set(-5.01, 0, 3 + i * 2);
                scene.add(sideWindowGroup2);
            }
            
            // Add a door
            const doorGroup = new THREE.Group();
            
            const doorGeometry = new THREE.PlaneGeometry(2, 3);
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x5c2e11,
                roughness: 0.7,
                map: roofTexture
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.z = 0.01;
            doorGroup.add(door);
            
            // Door handle
            const handleGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const handle = new THREE.Mesh(handleGeometry, new THREE.MeshStandardMaterial({
                color: 0xe0c010,
                roughness: 0.4,
                metalness: 0.8
            }));
            handle.position.set(0.6, -0.3, 0.1);
            doorGroup.add(handle);
            
            doorGroup.position.set(0, -2.5, 7.01);
            scene.add(doorGroup);
            
            // Water channel with realistic material
            const concreteTexture = new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/textures/brick_bump.jpg');
            concreteTexture.wrapS = concreteTexture.wrapT = THREE.RepeatWrapping;
            concreteTexture.repeat.set(3, 1);
            
            const channelGeometry = new THREE.BoxGeometry(6, 2, 10);
            const channelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.7,
                bumpMap: concreteTexture,
                bumpScale: 0.05
            });
            const channel = new THREE.Mesh(channelGeometry, channelMaterial);
            channel.position.set(0, -4, -2);
            channel.receiveShadow = true;
            scene.add(channel);
            
            // Add some pipes around the turbine house
            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x505050,
                roughness: 0.3,
                metalness: 0.8
            });
            
            // Main pipe from dam to turbine
            const mainPipeGeometry = new THREE.CylinderGeometry(1, 1, 10, 16);
            mainPipeGeometry.rotateX(Math.PI / 2);
            const mainPipe = new THREE.Mesh(mainPipeGeometry, pipeMaterial);
            mainPipe.position.set(0, -3, -1);
            mainPipe.castShadow = true;
            scene.add(mainPipe);
            
            // Smaller pipes
            const smallPipeGeometry = new THREE.CylinderGeometry(0.3, 0.3, 6, 16);
            for (let i = -1; i <= 1; i += 2) {
                const smallPipe = new THREE.Mesh(smallPipeGeometry, pipeMaterial);
                smallPipe.position.set(i * 2, -3, -1);
                smallPipe.castShadow = true;
                scene.add(smallPipe);
            }
        }
        
        function createTurbine() {
            // Turbine blades
            const bladeGeometry = new THREE.BoxGeometry(0.5, 4, 0.1);
            const bladeMaterial = new THREE.MeshStandardMaterial({
                color: 0x505050,
                roughness: 0.4,
                metalness: 0.8
            });
            
            turbine = new THREE.Group();
            for (let i = 0; i < 4; i++) {
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(0, 2, 0);
                blade.rotation.z = i * Math.PI / 2;
                turbine.add(blade);
            }
            
            turbine.position.set(0, -3, 0);
            turbine.castShadow = true;
            scene.add(turbine);
        }
        
        function createBulbAndLight() {
            // Bulb
            const bulbGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const bulbMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 1,
                roughness: 0.4,
                metalness: 0.8
            });
            
            bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(0, 5, 3);
            scene.add(bulb);
            
            // Light
            light = new THREE.PointLight(0xffff00, 1, 10);
            light.position.set(0, 5, 3);
            scene.add(light);
        }
        
        function createPowerLines() {
            // Power lines
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const wireMaterial = new THREE.LineBasicMaterial({
                color: 0x000000
            });
            
            for (let i = 0; i < 5; i++) {
                const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 10, 16);
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(i * 10 - 20, 0, 10);
                scene.add(pole);
                
                if (i > 0) {
                    const wireGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3((i - 1) * 10 - 20, 5, 10),
                        new THREE.Vector3(i * 10 - 20, 5, 10)
                    ]);
                    const wire = new THREE.Line(wireGeometry, wireMaterial);
                    scene.add(wire);
                }
            }
        }
        
        function createWaterfall() {
            // Waterfall
            const waterfallGeometry = new THREE.PlaneGeometry(6, 10);
            const waterfallMaterial = new THREE.MeshStandardMaterial({
                color: 0x0077be,
                transparent: true,
                opacity: 0.8,
                roughness: 0.2,
                metalness: 0.3,
                side: THREE.DoubleSide
            });
            
            waterfall = new THREE.Mesh(waterfallGeometry, waterfallMaterial);
            waterfall.position.set(0, -5, -3.5);
            waterfall.rotation.x = -Math.PI / 2;
            waterfall.visible = false;
            scene.add(waterfall);
        }
        
        function updateGatePosition() {
            const gatePosition = -2.5 + (gateOpeningPercentage / 100) * 5;
            gateLeft.position.y = gatePosition;
            gateRight.position.y = gatePosition;
            
            if (gateOpeningPercentage > 0) {
                waterfall.visible = true;
            } else {
                waterfall.visible = false;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - previousTime) / 1000;
            previousTime = currentTime;
            
            // Update turbine rotation
            turbineRotationSpeed = gateOpeningPercentage / 100;
            turbine.rotation.z += turbineRotationSpeed * deltaTime * Math.PI;
            
            // Update water animation
            water.userData.time += deltaTime;
            const vertices = water.geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 1] = water.userData.originalVertices[i + 1] + Math.sin(water.userData.time + vertices[i] * 0.1) * 0.2;
            }
            water.geometry.attributes.position.needsUpdate = true;
            
            // Update power output
            powerOutput = turbineRotationSpeed * 100;
            document.getElementById('powerOutput').textContent = `Power Output: ${powerOutput.toFixed(2)} kW`;
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize the scene
        init();
    </script>
</body>
</html>